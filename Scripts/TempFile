# #! /bin/bash
# # # #    read -r -p  "Enter Table Name :" Tname
# # #         # if [[ -e "${PWD}/$Tname" && -f "${PWD}/$Tname" ]] ; then
# # #         #     echo "Table '$Tname' already exists."
# # #         #     . /home/zalabany/DBMS-Bash-Project/Scripts/createTable.sh
# # #         # fi
# # #             # if [[ $colNum =~ ^[1-9][0-9]*$ ]]; then
# # #             #     break
# # #             # else
# # #             #     echo "Invalid input. Please enter a positive integer for the column count."
# # #             # fi

# # # read  -p "Enter 2 values :\n" v1 
# # # echo $v1 
# # # # #! /usr/bin/bash
# # # # tableExist(){
# # # #         local Tname="$1"
# # # #     while true ;do
# # # #     echo "Checking..."
# # # #   if [[  -e "${PWD}/$Tname" && -f "${PWD}/$Tname" ]]; then
# # # #         echo "Proceed WIth Inserting"
# # # #         break
# # # #         else 
# # # #             # Table Dosen't exists 
# # # #             echo "Table '$Tname' Dosen't exists. Choose another name."
# # # #             read -r -p "Enter Table Name again: " Tname
# # # #             continue
# # # #         fi
# # # #         done

# # # # }
# # # # function insertIntoTable() {
    
# # # #     read -r -p "Enter Table Name " Tname
# # # #     tableExist "${Tname}"
# # # #        #Dynamic Location SomeHow
# # # #      IFS=$'\n' read -d '' -r -a lines < "${PWD}/${Tname}.meta_data" 
# # # #     #  mapfile -t lines < /home/zalabany/DBMS-Bash-Project/DataBase/DB1/TB3.meta_data
# # # #     #  lines=($(awk '{print $0}' /home/zalabany/DBMS-Bash-Project/DataBase/DB1/TB3.meta_data))
# # # #         End=$(( ${#lines[@]} - 1 ))
# # # #         tableContent=""  #loop The Lines (Lines Contains The MetaData That The user Put in the Create Table Section)
# # # #         for i in "${!lines[@]}";do 
# # # #         echo $i
# # # #         #Change The field Seperator To  + Accept The Value As Array: Instead of the Default Note: Default  IFS That is " "
# # # #         IFS=':' read -r -a columnContent <<< "${lines[i]}";
            
# # # #         colName=${columnContent[0]};
# # # #         colDataType=${columnContent[1]};
# # # #         colPK=${columnContent[2]};

# # # #         #test flags
# # # #         dataTypeFlag=0; #true
# # # #         pkFlag=0;   #true

# # # #         #read new column value from user
# # # #         read -r -p "Enter $colName: " ColValue;
# # # #         numRegex='^[0-9]+$'
# # # #         # validate dataType
# # # #         if [[ $colDataType == "int" ]]; then
# # # #             if ! [[ $ColValue =~ $numRegex ]]; then
# # # #                 dataTypeFlag=1; #false1
# # # #                 errorFlag=1; #false
# # # #                 echo "ERROR: Value must be a Intergar.";
# # # #             fi 
# # # #         fi

# # # #         # validate if PK
# # # #         if [[ $colPK -eq "PK" ]]; then
# # # #             # get all column data from Data/tableName
# # # #             IFS=$'\n' read -d '' -r -a idCheck < "${PWD}/${Tname}"  #
            
# # # #             #loop over column data to check pk if unique 
# # # #             for j in "${!idCheck[@]}";do
# # # #                 IFS=':' read -r -a record <<< "${idCheck[$j]}"; # split Record Into Pieces To Check Line By LIne
# # # #                 if [[ ${record[$i]} -eq $ColValue ]]; then
# # # #                     pkFlag=1; #false(not-unique)
# # # #                     echo "${record[$i]} ${idCheck}"
# # # #                     errorFlag=1; #false
# # # #                     echo "ERROR: Primary key must be unique.";
# # # #                     read -r -p "Enter ${colName} again: " ColValue

# # # #                 fi
# # # #             done
# # # #         fi

# # # #         if [[ $i -eq $End  ]] ;then
# # # #          tableContent+="${ColValue}"
# # # #          else
# # # #          tableContent+="${ColValue}:"
# # # #              fi
# # # # done

  
# # # #  echo -e "${tableContent}" >> ${PWD}/${Tname}

# # # # }
# # # # insertIntoTable

# # # #     # print "Enter The Data you Want To insert :" $1

# # # #     # printf "Enter The Data you Want To insert :"
# # # #     # getline colname 

# # # #!/usr/bin/bash
# # # # shopt -s extglob # Enable extended pattern matching
# # # # # Function to validate column count
# # # # function createTableContent() {
# # # #     local colNum="$1"
# # # #     while true; do
# # # #         # Validate that the input is a positive integer
# # # #         if [[ $colNum =~ ^[1-9][0-9]*$ ]]; then
# # # #             break
# # # #         else
# # # #             echo "Invalid input. Please enter a positive integer for the column count."
# # # #             read -r -p "Enter column count again: " colNum
# # # #       fi
# # # #     done
# # # # }
# # # # # Function to create a table
# # # # function createTable() {
# # # #     PS1="Select Option: "
# # # #     while true; do
# # # #         # Prompt user for the table name
# # # #         read -r -p "Enter Table Name: " Tname
# # # #         if [[ ! -e "${PWD}/$Tname" ]]; then
# # # #             # Table doesn't exist, proceed to create it
# # # #             read -r -p "Enter ${Tname} Columns Number: " colNum
# # # #             createTableContent "$colNum" # Validate column count
# # # #             echo -e "Creating table '$Tname' with $colNum columns..."
# # # #             break
# # # #         elif [[ -e "${PWD}/$Tname" && -f "${PWD}/$Tname" ]]; then
# # # #             # Table already exists as a file
# # # #             echo "Table '$Tname' already exists. Choose another name."
# # # #         else
# # # #             # Table exists as a directory
# # # #             echo "'$Tname' exists as a directory. Recreating your table as a file..."
# # # #             rm -r "${PWD}/$Tname" # Remove the directory
# # # #             read -r -p "Enter Columns Number: " colNum
# # # #             createTableContent "$colNum" # Validate column count
# # # #             echo -e "Creating table '$Tname' with $colNum columns..."
# # # #             break
# # # #         fi
# # # #     done
# # # # #-----------------------------------------------------------------------------------------------------------------
# # # #         declare -i num=0
# # # #         pkFlag=0
# # # #         tableSchema="" 
# # # #         echo "The first column will be the Primary Key (PK)."W
# # # #         while ((num < colNum)); do
# # # #             echo "Enter Column $((num + 1)) Name:"
# # # #             read -r colName
# # # #             if [[ ! $colName =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then
# # # #                 echo "Invalid column name. Use letters, numbers, and underscores only."
# # # #                 continue
# # # #             fi
# # # #             echo "Enter Column $((num + 1)) Datatype (int/str):"
# # # #             read -r colType
# # # #             if [[ $colType != "int" && $colType != "str" ]]; then
# # # #                 echo "Invalid datatype. Only 'int' or 'str' are allowed."
# # # #                 continue #Re Ask for The Data Type
# # # #             fi
# # # #             if [[ $pkFlag -eq 0 ]]; then
# # # #                 tableSchema+="${colName}:${colType}:PK\n" #MetaData FIle
# # # #                 pkFlag=1
# # # #             else
# # # #                 tableSchema+="$colName:$colType\n"
# # # #             fi
# # # #             ((num++))
# # # #         done
# # # #         touch   "${Tname}.meta_data"
# # # #         touch   "${Tname}"
# # # #         echo -e "${tableSchema}" > "${Tname}.meta_data"
# # # #         echo -e "Table ${Tname} Successfuly Created"
# # # # }
# # # # createTable
# # # echo -e "\nListing Columns\nIf you choose a column, you will update that column.\n*Note: It is not wise to change the PK of a table*"

# # # select colName in "${columnName[@]}" "value" "Exit"; do
# # #     if [[ "$colName" == "Exit" ]]; then
# # #         echo "Exiting updating process."
# # #         break
# # #     elif [[ -n "$colName" && "$colName" != "value" ]]; then
# # #         # Find the index of the selected column
# # #         for i in "${!columnName[@]}"; do
# # #             if [[ "${columnName[$i]}" == "$colName" ]]; then
# # #                 colIndex=$i
# # #                 break
# # #             fi
# # #         done

# # #         echo "You selected: $colName (Index: $colIndex)"
# # #         if [[ "$colName" == "${columnName[0]}" ]]; then
# # #             echo "You will update the $colName column."
# # #             read -r -p "Enter the Primary Key value: " currentValue
# # #             read -r -p "Enter the new value: " newValue
# # #         else
# # #             read -r -p "Enter the current value: " currentValue
# # #             read -r -p "Enter the new value: " newValue
# # #         fi
# # #         break
# # #     elif [[ "$colName" == "value" ]]; then
# # #         echo -e "\nSelect the column to update its values:"
# # #         select valueColumn in "${columnName[@]}" "Exit"; do
# # #             if [[ "$valueColumn" == "Exit" ]]; then
# # #                 echo "Exiting program."
# # #                 break
# # #             elif [[ -n "$valueColumn" ]]; then
# # #                 # Find the index of the selected column
# # #                 for i in "${!columnName[@]}"; do
# # #                     if [[ "${columnName[$i]}" == "$valueColumn" ]]; then
# # #                         colIndex=$i
# # #                         break
# # #                     fi
# # #                 done

# # #                 echo "You selected column: $valueColumn (Index: $colIndex)"
# # #                 read -r -p "Enter the current value: " currentValue
# # #                 read -r -p "Enter the new value: " newValue
# # #                 echo "Updating $valueColumn: $currentValue -> $newValue"
# # #                 # Add the actual update logic here if needed
# # #                 break
# # #             else
# # #                 echo "Invalid selection, try again."
# # #             fi
# # #         done
# # #         break
# # #     else
# # #         echo "Invalid selection, try again."
# # #     fi
# # # done

# # # awk -F : -v colIndex="${colIndex}" -v oldValue="${oldValue}" -v newValue="${newValue}" '
# # # {
# # #     if ($colIndex == oldValue) {
# # #         $colIndex = newValue
# # #         print $0
# # #     }
# # # }' }' /home/zalabany/DBMS-Bash-Project/DataBase/DB1/TB1 > /home/zalabany/DBMS-Bash-Project/DataBase/DB1/TB1.tmp && mv /home/zalabany/DBMS-Bash-Project/DataBase/DB1/TB1.tmp /home/zalabany/DBMS-Bash-Project/DataBase/DB1/TB1

# # #     # print $colIndex
# # # # print $colIndex
# # # # echo $colIndex $colValue
# # #!/bin/bash
# # shopt -s extglob # Enable extended pattern matching
# # function UpdateMenu(){
# # # List files in the current directory, excluding `.meta_data` files
# # list=($(ls "${PWD}" | grep -v '\.meta_data$'))
# # # Dynamically present the file selection menu
# # echo -e "Listing Files:\n"
# # select item in "${list[@]}" "Exit"; do
# #     if [[ "$item" == "Exit" ]]; then
# #         echo "Exiting program."
# #         exit 0
# #     elif [[ -n "$item" ]]; then
# #         echo "You selected: $item"
# #         choice="${item}"
# #         break  
# #     else
# #         echo "Invalid selection, try again."
# #     fi
# # done

# # # Construct the metadata file path
# # metadataFile="${PWD}/${choice}.meta_data"
# # if [[ ! -f "$metadataFile" ]]; then
# #     echo "Metadata file not found for $choice. Exiting."
# #     exit 1
# # fi

# # # Read column names from the metadata file
# # columnName=($(awk -F: '{print $1}' "$metadataFile"))
# # echo -e "Columns available: ${columnName[@]}"

# # # Main column selection menu
# # echo -e "\nListing Columns\nIf you choose a column, you will update that column.\n*Note: It is not wise to change the PK of a table*"
# # select colName in "${columnName[@]}" "value" "Exit"; do
# #     if [[ "$colName" == "Exit" ]]; then
# #         echo "Exiting updating process."
# #         break
# #     elif [[ -n "$colName" && "$colName" != "value" ]]; then
# #         # Find the index of the selected column
# #         for i in "${!columnName[@]}"; do
# #             if [[ "${columnName[$i]}" == "$colName" ]]; then
# #                 colIndex=$i
# #                 break
# #             fi
# #         done 
# #         echo "You selected: $colName (Index: $colIndex)"
        
# #         # Check if it's the primary key column (assume first column is PK)
# #         if [[ "$colName" == "${columnName[0]}" ]]; then
# #             echo "You are attempting to update the Primary Key (PK) column."
# #             read -r -p "Enter the PrimaryKey Value: " currentValue
# #             read -r -p "Enter the new value: " newValue
# #         else
# #             echo "You are updating the $colName column."
# #             read -r -p "Enter the current value: " currentValue
# #             read -r -p "Enter the new value: " newValue
# #             . ~/DBMS-Bash-Project/Scripts/updateRecord.sh "$colIndex" "$currentValue" "$newValue" "$item"

# #         fi
# #         break
# #     elif [[ "$colName" == "value" ]]; then
# #         echo -e "\nSelect the column to update its values:"
# #         select valueColumn in "${columnName[@]}" "Exit"; do
# #             if [[ "$valueColumn" == "Exit" ]]; then
# #                 echo "Exiting program."
# #                 break
# #             elif [[ -n "$valueColumn" ]]; then
# #                 # Find the index of the selected column
# #                 for i in "${!columnName[@]}"; do
# #                     if [[ "${columnName[$i]}" == "$valueColumn" ]]; then
# #                         colIndex=$i
# #                         break
# #                     fi
# #                 done 
# #                 echo "You selected column: $valueColumn (Index: $colIndex)"
# #                 read -r -p "Enter the current value: " currentValue
# #                 read -r -p "Enter the new value: " newValue
# #                 echo "Updating $valueColumn: $currentValue -> $newValue"
# #                 # Add the actual update logic here if needed
# #                 break  
# #             else
# #                 echo "Invalid selection, try again."
# #             fi
# #      done
# #         break
# #     else
# #         echo "Invalid selection, try again."
# #     fi
# # done
# # }
# # UpdateMenu

# # #!/bin/bash
# # shopt -s extglob # Enable extended pattern matching
# # # Initialize variables
# # colIndex=$(($1+1))  # Example column index, update as needed
# # oldValue=$2
# # newValue=$3
# # tableName=$4
# # echo  $colIndex $oldValue $newValue $tableName
# # # Ensure the required variables are not empty
# # if [[ -z $oldValue && -z $colIndex && -z $newValue && -z $tableName ]]; then
# #     echo "The 3 Values Mustn't Be Empty"
# #     exit 1
# # fi

# # # Use awk to find and modify the column value
# # oldValueLocation=$(
# #     awk -v colIndex="${colIndex}" -v oldValue="${oldValue}" -v newValue="${newValue}" '
# #     BEGIN { FS = ":"; OFS = ":" }
# #     {
# #         if ($colIndex == oldValue) {
# #             $colIndex = newValue  # Update the value in the column
# #             print $0  # Print the modified line
# #         }
# #     }' /home/zalabany/DBMS-Bash-Project/DataBase/DB1/$tableName
# # )

# # # Check if the line is found and update the file
# # echo "${oldValueLocation}"
# # if [[ ! -z $oldValueLocation ]]; then
# #     # echo -e "Line Found Updating To ---> \n$oldValueLocation"

# #     # Use sed to update the file
# #     sed -i "s/${oldValue}/${newValue}/g" /home/zalabany/DBMS-Bash-Project/DataBase/DB1/$tableName

# #     echo "File updated successfully."
# # else
# #     echo "Not Found"
# # fi
# --------------------------------------------------------------------------------------------------------------------
# #!/bin/bash
# shopt -s extglob # Enable extended pattern matching

# function UpdateMenu(){
#     # List files in the current directory, excluding `.meta_data` files
#     list=($(ls "${PWD}" | grep -v '\.meta_data$'))
    
#     # Dynamically present the file selection menu
#     echo -e "Listing Files:\n"
#     select item in "${list[@]}" "Exit"; do
#         if [[ "$item" == "Exit" ]]; then
#             echo "Exiting program."
#             exit 0
#         elif [[ -n "$item" ]]; then
#             echo "You selected: $item"
#             choice="${item}"
#             break  
#         else
#             echo "Invalid selection, try again."
#         fi
#     done

#     # Construct the metadata file path
#     metadataFile="${PWD}/${choice}.meta_data"
#     if [[ ! -f "$metadataFile" ]]; then
#         echo "Metadata file not found for $choice. Exiting."
#         exit 1
#     fi

#     # Read column names from the metadata file
#     columnName=($(awk -F: '{print $1}' "$metadataFile"))
#     echo -e "Columns available: ${columnName[@]}"

#     # Main column selection menu
#     echo -e "\nListing Columns\nIf you choose a column, you will update that column.\n*Note: It is not wise to change the PK of a table*"
#     select colName in "${columnName[@]}" "value" "Exit"; do
#         if [[ "$colName" == "Exit" ]]; then
#             echo "Exiting updating process."
#             break
#         elif [[ -n "$colName" && "$colName" != "value" ]]; then
#             # Find the index of the selected column
#             for i in "${!columnName[@]}"; do
#                 if [[ "${columnName[$i]}" == "$colName" ]]; then
#                     colIndex=$i
#                     break
#                 fi
#             done 
#             echo "You selected: $colName (Index: $colIndex)"
            
#             # Check if it's the fprimary key column (assume first column is PK)
#             if [[ "$colName" == "${columnName[0]}" ]]; then
#                 echo "You are attempting to update the Primary Key (PK) column."
#                 read -r -p "Enter the PrimaryKey Value: " currentValue
#                 read -r -p "Enter the new value: " newValue

#                 # if [[  "$newValue" ]]
#                 . ~/DBMS-Bash-Project/Scripts/updateAll.sh "$colIndex" "$currentValue" "$newValue" "$item" "PK"
#             else
#                 echo "You are updating the $colName column."
#                 read -r -p "Enter the current value: " currentValue
#                 read -r -p "Enter the new value: " newValue
                
#                 # Check if updateRecord.sh exists and source it
#                 if [[ -f ~/DBMS-Bash-Project/Scripts/updateAll.sh ]]; then
#                     . ~/DBMS-Bash-Project/Scripts/updateAll.sh "$colIndex" "$currentValue" "$newValue" "$item" 
#                 else
#                     echo "updateRecord.sh script not found!"
#                 fi
#             fi
#             break
#         elif [[ "$colName" == "value" ]]; then
#             echo -e "\nSelect the column to update its values:"
#            for i in "${!columnName[@]}"; do
#                 if [[ "${columnName[$i]}" == "$colName" ]]; then
#                     colIndex=$i
#                     break
#                 fi
#             done 
#                     echo "Select Spicfic Record Enter 2 values PK and the value you want to Change"
#                     read -r -p "Enter the Primary Key value: " PK
#                     read -r -p "Enter the current value: " currentValue
#                     read -r -p "Enter the new value : " newValue
#                     . ~/DBMS-Bash-Project/Scripts/updateAll.sh "$colIndex" "$currentValue" "$newValue" "$item" 
                
#                     # Add the actual update logic here if needed
#                     break  
#                 else
#                     echo "Invalid selection, try again."
#                 fi
#             break
#         else
#             echo "Invalid selection, try again."
#         fi
#     done
# }

# UpdateMenu
